    [ContentProperty("Window")]
    public sealed class CloseWindow : CodeActivity
    {
      public InArgument<Window> Window{get;set;}
    }
    表示Window属性是XAML中的内容属性


WPF绑定值类型的数组时需要加标记
using System.Runtime.InteropServices;
public struct Test
{
    [MarshalAs (UnmanagedType.ByValArray, SizeConst=50)] 
    public char[] names;
    public int ID;
}

数据绑定发生在源对象和目标对象之间，当源对象或目标对象的属性值发生改变时，所绑定的对象也会跟着发生改变 
         * 数据绑定的目标对象一定是Dependency Object，所绑定的目标对象的属性一定是Dependency Property 
         * 源对象可以是Dependency Object/Dependency Property，也可以是一般的.net对象
绑定模式：
         *  OneWay：源对象发生改变时，目标对象也跟着改变；目标对象发生改变时，源对象不变化 
         *  TwoWay：源对象发生改变时，目标对象也跟着改变；目标对象发生改变时，源对象也跟着变化 
         *  OneTime：只在初始化时发生作用，数据从源对象传递到目标对象 
         *  OneWayToSource：和OneWay类似，不同的是源对象随着目标对象的变化而变化 
         *  Default：源对象的属性如果是只读的，选择为OneWay;如果源对象的属性是读写的，选择为TwoWay,大多的情况 适用 
      对象是否实现了INotifyPropertyChanged，是选择绑定的依据 
【初次使用常迷惑的问题是，绑定的.net对象修改时，而目标不变化，此时主要的问题是一般的.net对象没有实现
INotifyPropertyChanged的原因；对于集合的绑定也类似，可以使用ObservableCollection <T>这个容器类构造集合辅助处理】
反过来修改目标，对源对象的修改没有限定；
如果源目标是集合，则要看情况而定
